!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("babylonjs")):"function"==typeof define&&define.amd?define("babylonjs-serializers",["babylonjs"],t):"object"==typeof exports?exports["babylonjs-serializers"]=t(require("babylonjs")):e.SERIALIZERS=t(e.BABYLON)}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(function(e){return(()=>{"use strict";var t={520:t=>{t.exports=e}},r={};function s(e){var n=r[e];if(void 0!==n)return n.exports;var o=r[e]={exports:{}};return t[e](o,o.exports,s),o.exports}s.d=(e,t)=>{for(var r in t)s.o(t,r)&&!s.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};return(()=>{s.d(n,{default:()=>O});var e={};s.r(e),s.d(e,{OBJExport:()=>h});var t={};s.r(t),s.d(t,{__IGLTFExporterExtension:()=>d});var r={};s.r(r),s.d(r,{GLTFData:()=>g});var o={};s.r(o),s.d(o,{GLTF2Export:()=>A});var a={};s.r(a),s.d(a,{KHR_lights_punctual:()=>E,KHR_materials_clearcoat:()=>C,KHR_materials_sheen:()=>v,KHR_materials_unlit:()=>S,KHR_texture_transform:()=>F});var i={};s.r(i),s.d(i,{GLTF2Export:()=>A,GLTFData:()=>g,KHR_lights_punctual:()=>E,KHR_materials_clearcoat:()=>C,KHR_materials_sheen:()=>v,KHR_materials_unlit:()=>S,KHR_texture_transform:()=>F,_BinaryWriter:()=>T,_Exporter:()=>x,_GLTFAnimation:()=>m,_GLTFMaterialExporter:()=>_,_GLTFUtilities:()=>p,__IGLTFExporterExtensionV2:()=>y});var l={};s.r(l),s.d(l,{STLExport:()=>B});var c={};s.r(c),s.d(c,{GLTF2Export:()=>A,GLTFData:()=>g,KHR_lights_punctual:()=>E,KHR_materials_clearcoat:()=>C,KHR_materials_sheen:()=>v,KHR_materials_unlit:()=>S,KHR_texture_transform:()=>F,OBJExport:()=>h,STLExport:()=>B,_BinaryWriter:()=>T,_Exporter:()=>x,_GLTFAnimation:()=>m,_GLTFMaterialExporter:()=>_,_GLTFUtilities:()=>p,__IGLTFExporterExtension:()=>d,__IGLTFExporterExtensionV2:()=>y});var u=s(520);class h{static OBJ(e,t,r,s){const n=[];let o=1,a=1;t&&(r||(r="mat"),n.push("mtllib "+r+".mtl"));for(let r=0;r<e.length;r++){n.push("g object"+r),n.push("o object_"+r);let l=null;if(s){const t=e[r].computeWorldMatrix(!0);l=new u.Matrix,t.invertToRef(l),e[r].bakeTransformIntoVertices(t)}if(t){const t=e[r].material;t&&n.push("usemtl "+t.id)}const c=e[r].geometry;if(!c){u.Tools.Warn("No geometry is present on the mesh");continue}const h=c.getVerticesData("position"),f=c.getVerticesData("normal"),d=c.getVerticesData("uv"),p=c.getIndices();let m=0,g=0;if(h&&p){for(var i=0;i<h.length;i+=3)e[0].getScene().useRightHandedSystem?n.push("v "+h[i]+" "+h[i+1]+" "+h[i+2]):n.push("v "+h[i]+" "+h[i+1]+" "+-h[i+2]),m++;if(null!=f)for(i=0;i<f.length;i+=3)n.push("vn "+f[i]+" "+f[i+1]+" "+f[i+2]);if(null!=d)for(i=0;i<d.length;i+=2)n.push("vt "+d[i]+" "+d[i+1]),g++;for(i=0;i<p.length;i+=3){const e=[String(p[i+2]+o),String(p[i+1]+o),String(p[i]+o)],t=[String(p[i+2]+a),String(p[i+1]+a),String(p[i]+a)],r=["","",""],s=e,l=null!=d?t:r,c=null!=f?e:r;n.push("f "+s[0]+"/"+l[0]+"/"+c[0]+" "+s[1]+"/"+l[1]+"/"+c[1]+" "+s[2]+"/"+l[2]+"/"+c[2])}s&&l&&e[r].bakeTransformIntoVertices(l),o+=m,a+=g}else u.Tools.Warn("There are no position vertices or indices on the mesh!")}return n.join("\n")}static MTL(e){const t=[],r=e.material;return t.push("newmtl mat1"),t.push("  Ns "+r.specularPower.toFixed(4)),t.push("  Ni 1.5000"),t.push("  d "+r.alpha.toFixed(4)),t.push("  Tr 0.0000"),t.push("  Tf 1.0000 1.0000 1.0000"),t.push("  illum 2"),t.push("  Ka "+r.ambientColor.r.toFixed(4)+" "+r.ambientColor.g.toFixed(4)+" "+r.ambientColor.b.toFixed(4)),t.push("  Kd "+r.diffuseColor.r.toFixed(4)+" "+r.diffuseColor.g.toFixed(4)+" "+r.diffuseColor.b.toFixed(4)),t.push("  Ks "+r.specularColor.r.toFixed(4)+" "+r.specularColor.g.toFixed(4)+" "+r.specularColor.b.toFixed(4)),t.push("  Ke "+r.emissiveColor.r.toFixed(4)+" "+r.emissiveColor.g.toFixed(4)+" "+r.emissiveColor.b.toFixed(4)),r.ambientTexture&&t.push("  map_Ka "+r.ambientTexture.name),r.diffuseTexture&&t.push("  map_Kd "+r.diffuseTexture.name),r.specularTexture&&t.push("  map_Ks "+r.specularTexture.name),r.bumpTexture&&t.push("  map_bump -imfchan z "+r.bumpTexture.name),r.opacityTexture&&t.push("  map_d "+r.opacityTexture.name),t.join("\n")}}var f,d=0;class p{static _CreateBufferView(e,t,r,s,n){const o={buffer:e,byteLength:r};return t&&(o.byteOffset=t),n&&(o.name=n),s&&(o.byteStride=s),o}static _CreateAccessor(e,t,r,s,n,o,a,i){const l={name:t,bufferView:e,componentType:s,count:n,type:r};return null!=a&&(l.min=a),null!=i&&(l.max=i),null!=o&&(l.byteOffset=o),l}static _CalculateMinMaxPositions(e,t,r,s){const n=[1/0,1/0,1/0],o=[-1/0,-1/0,-1/0];let a,i,l;if(r)for(let c=t,h=t+r;c<h;++c){a=3*c,i=u.Vector3.FromArray(e,a),s&&p._GetRightHandedPositionVector3FromRef(i),l=i.asArray();for(let e=0;e<3;++e){const t=l[e];t<n[e]&&(n[e]=t),t>o[e]&&(o[e]=t),++a}}return{min:n,max:o}}static _GetRightHandedPositionVector3(e){return new u.Vector3(e.x,e.y,-e.z)}static _GetRightHandedPositionVector3FromRef(e){e.z*=-1}static _GetRightHandedPositionArray3FromRef(e){e[2]*=-1}static _GetRightHandedNormalVector3(e){return new u.Vector3(e.x,e.y,-e.z)}static _GetRightHandedNormalVector3FromRef(e){e.z*=-1}static _GetRightHandedNormalArray3FromRef(e){e[2]*=-1}static _GetRightHandedVector4FromRef(e){e.z*=-1,e.w*=-1}static _GetRightHandedArray4FromRef(e){e[2]*=-1,e[3]*=-1}static _GetRightHandedQuaternionFromRef(e){e.x*=-1,e.y*=-1}static _GetRightHandedQuaternionArrayFromRef(e){e[0]*=-1,e[1]*=-1}static _NormalizeTangentFromRef(e){const t=Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z);t>0&&(e.x/=t,e.y/=t,e.z/=t)}static _GetDataAccessorElementCount(e){switch(e){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}}!function(e){e[e.INTANGENT=0]="INTANGENT",e[e.OUTTANGENT=1]="OUTTANGENT"}(f||(f={}));class m{static _CreateNodeAnimation(e,t,r,s,n,o){const a=[],i=[],l=t.getKeys(),c=m.calculateMinMaxKeyFrames(l),h=m._DeduceInterpolation(l,r,n),f=c.max-c.min,d=h.interpolationType,p=h.shouldBakeAnimation;return p?m._CreateBakedAnimation(e,t,r,c.min,c.max,t.framePerSecond,o,a,i,c,s,n):"LINEAR"===d||"STEP"===d?m._CreateLinearOrStepAnimation(e,t,r,f,a,i,s,n):"CUBICSPLINE"===d?m._CreateCubicSplineAnimation(e,t,r,f,a,i,s,n):m._CreateBakedAnimation(e,t,r,c.min,c.max,t.framePerSecond,o,a,i,c,s,n),a.length&&i.length?{inputs:a,outputs:i,samplerInterpolation:d,inputsMin:p?c.min:u.Tools.FloatRound(c.min/t.framePerSecond),inputsMax:p?c.max:u.Tools.FloatRound(c.max/t.framePerSecond)}:null}static _DeduceAnimationInfo(e){let t=null,r="VEC3",s=!1;const n=e.targetProperty.split(".");switch(n[0]){case"scaling":t="scale";break;case"position":t="translation";break;case"rotation":r="VEC4",t="rotation";break;case"rotationQuaternion":r="VEC4",s=!0,t="rotation";break;case"influence":r="SCALAR",t="weights";break;default:u.Tools.Error(`Unsupported animatable property ${n[0]}`)}return t?{animationChannelTargetPath:t,dataAccessorType:r,useQuaternion:s}:(u.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(e,t,r,s,n,o,a,i,l,c){let h;if(e instanceof u.TransformNode&&e.animations)for(const n of e.animations){const u=m._DeduceAnimationInfo(n);u&&(h={name:n.name,samplers:[],channels:[]},m.AddAnimation(`${n.name}`,n.hasRunningRuntimeAnimations?t:h,e,n,u.dataAccessorType,u.animationChannelTargetPath,s,o,a,i,l,u.useQuaternion,c),h.samplers.length&&h.channels.length&&r.push(h))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(e,t,r,s,n,o,a,i,l,c){let h;if(e instanceof u.Mesh){const n=e.morphTargetManager;if(n)for(let f=0;f<n.numTargets;++f){const d=n.getTarget(f);for(const p of d.animations){const d=new u.Animation(`${p.name}`,"influence",p.framePerSecond,p.dataType,p.loopMode,p.enableBlending),g=[],_=p.getKeys();for(let e=0;e<_.length;++e){const t=_[e];for(let e=0;e<n.numTargets;++e)e==f?g.push(t):g.push({frame:t.frame,value:0})}d.setKeys(g);const x=m._DeduceAnimationInfo(d);x&&(h={name:d.name,samplers:[],channels:[]},m.AddAnimation(p.name,p.hasRunningRuntimeAnimations?t:h,e,d,x.dataAccessorType,x.animationChannelTargetPath,s,o,a,i,l,x.useQuaternion,c,n.numTargets),h.samplers.length&&h.channels.length&&r.push(h))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(e,t,r,s,n,o,a,i,l){var c;let h;if(e.animationGroups){const s=e.animationGroups;for(const f of s){const s=new Map,d=new Map,p=new Set,g=f.to-f.from;h={name:f.name,channels:[],samplers:[]};for(let t=0;t<f.targetedAnimations.length;++t){const g=f.targetedAnimations[t],_=g.target,x=g.animation;if(_ instanceof u.TransformNode||1===_.length&&_[0]instanceof u.TransformNode){const e=m._DeduceAnimationInfo(g.animation);if(e){const t=_ instanceof u.TransformNode?_:_[0],s=i[t.uniqueId];m.AddAnimation(`${x.name}`,h,t,x,e.dataAccessorType,e.animationChannelTargetPath,r,n,o,a,s,e.useQuaternion,l)}}else if((_ instanceof u.MorphTarget||1===_.length&&_[0]instanceof u.MorphTarget)&&m._DeduceAnimationInfo(g.animation)){const t=_ instanceof u.MorphTarget?_:_[0];if(t){const r=e.morphTargetManagers.find((e=>{for(let r=0;r<e.numTargets;++r)if(e.getTarget(r)===t)return!0;return!1}));if(r){const n=e.meshes.find((e=>e.morphTargetManager===r));n&&(s.has(n)||s.set(n,new Map),null===(c=s.get(n))||void 0===c||c.set(t,x),p.add(n),d.set(n,x))}}}}p.forEach((e=>{const t=e.morphTargetManager;let i=null;const c=[],p=d.get(e).getKeys(),_=p.length;for(let r=0;r<_;++r)for(let n=0;n<t.numTargets;++n){const o=t.getTarget(n),a=s.get(e);if(a){const t=a.get(o);t?(i||(i=new u.Animation(`${f.name}_${e.name}_MorphWeightAnimation`,"influence",t.framePerSecond,u.Animation.ANIMATIONTYPE_FLOAT,t.loopMode,t.enableBlending)),c.push(t.getKeys()[r])):c.push({frame:f.from+g/_*r,value:o.influence,inTangent:p[0].inTangent?0:void 0,outTangent:p[0].outTangent?0:void 0})}}i.setKeys(c);const x=m._DeduceAnimationInfo(i);x&&m.AddAnimation(`${f.name}_${e.name}_MorphWeightAnimation`,h,e,i,x.dataAccessorType,x.animationChannelTargetPath,r,n,o,a,!1,x.useQuaternion,l,null==t?void 0:t.numTargets)})),h.channels.length&&h.samplers.length&&t.push(h)}}}static AddAnimation(e,t,r,s,n,o,a,i,l,c,u,h,f,d){const g=m._CreateNodeAnimation(r,s,o,u,h,f);let _,x,T,y,A,b,F;if(g){if(d){let e=0,t=0;const r=[];for(;g.inputs.length>0;)t=g.inputs.shift(),e%d==0&&r.push(t),e++;g.inputs=r}const s=a[r.uniqueId];let u=4*g.inputs.length;_=p._CreateBufferView(0,i.getByteOffset(),u,void 0,`${e}  keyframe data view`),l.push(_),g.inputs.forEach((function(e){i.setFloat32(e)})),x=p._CreateAccessor(l.length-1,`${e}  keyframes`,"SCALAR",5126,g.inputs.length,null,[g.inputsMin],[g.inputsMax]),c.push(x),T=c.length-1,A=g.outputs.length,u=4*p._GetDataAccessorElementCount(n)*g.outputs.length,_=p._CreateBufferView(0,i.getByteOffset(),u,void 0,`${e}  data view`),l.push(_),g.outputs.forEach((function(e){e.forEach((function(e){i.setFloat32(e)}))})),x=p._CreateAccessor(l.length-1,`${e}  data`,n,5126,A,null,null,null),c.push(x),y=c.length-1,b={interpolation:g.samplerInterpolation,input:T,output:y},t.samplers.push(b),F={sampler:t.samplers.length-1,target:{node:s,path:o}},t.channels.push(F)}}static _CreateBakedAnimation(e,t,r,s,n,o,a,i,l,c,h,f){let d;const p=u.Quaternion.Identity();let g,_=null,x=null,T=null,y=null,A=null,b=null;c.min=u.Tools.FloatRound(s/o);const F=t.getKeys();for(let s=0,c=F.length;s<c;++s){if(b=null,T=F[s],s+1<c)if(y=F[s+1],T.value.equals&&T.value.equals(y.value)||T.value===y.value){if(0!==s)continue;b=T.frame}else b=y.frame;else{if(A=F[s-1],T.value.equals&&T.value.equals(A.value)||T.value===A.value)continue;b=n}if(b)for(let s=T.frame;s<=b;s+=a){if(g=u.Tools.FloatRound(s/o),g===_)continue;_=g,x=g;const n={key:0,repeatCount:0,loopMode:t.loopMode};d=t._interpolate(s,n),m._SetInterpolatedValue(e,d,g,t,r,p,i,l,h,f)}}x&&(c.max=x)}static _ConvertFactorToVector3OrQuaternion(e,t,r,s,n,o,a){let i,l,c=null;const h=m._GetBasePositionRotationOrScale(t,n,o,a);if(s===u.Animation.ANIMATIONTYPE_FLOAT)switch(i=r.targetProperty.split("."),l=i?i[1]:"",c=a?u.Quaternion.FromArray(h).normalize():u.Vector3.FromArray(h),l){case"x":case"y":c[l]=o&&a&&"scale"!==n?-e:e;break;case"z":c[l]=o&&!a&&"scale"!==n?-e:e;break;case"w":c.w=e;break;default:u.Tools.Error(`glTFAnimation: Unsupported component type "${l}" for scale animation!`)}return c}static _SetInterpolatedValue(e,t,r,s,n,o,a,i,l,c){const h=s.dataType;let f;a.push(r),"number"==typeof t&&e instanceof u.TransformNode&&(t=this._ConvertFactorToVector3OrQuaternion(t,e,s,h,n,l,c)),t&&("rotation"===n?(c?o=t:(f=t,u.Quaternion.RotationYawPitchRollToRef(f.y,f.x,f.z,o)),l&&(p._GetRightHandedQuaternionFromRef(o),e.parent||(o=u.Quaternion.FromArray([0,1,0,0]).multiply(o))),i.push(o.asArray())):"weights"===n?i.push([t]):(f=t,l&&"scale"!==n&&(p._GetRightHandedPositionVector3FromRef(f),e.parent||(f.x*=-1,f.z*=-1)),i.push(f.asArray())))}static _CreateLinearOrStepAnimation(e,t,r,s,n,o,a,i){for(const s of t.getKeys())n.push(s.frame/t.framePerSecond),m._AddKeyframeValue(s,t,o,r,e,a,i)}static _CreateCubicSplineAnimation(e,t,r,s,n,o,a,i){t.getKeys().forEach((function(l){n.push(l.frame/t.framePerSecond),m.AddSplineTangent(e,f.INTANGENT,o,r,"CUBICSPLINE",l,s,i,a),m._AddKeyframeValue(l,t,o,r,e,a,i),m.AddSplineTangent(e,f.OUTTANGENT,o,r,"CUBICSPLINE",l,s,i,a)}))}static _GetBasePositionRotationOrScale(e,t,r,s){let n;return"rotation"===t?s?e.rotationQuaternion?(n=e.rotationQuaternion.asArray(),r&&(p._GetRightHandedQuaternionArrayFromRef(n),e.parent||(n=u.Quaternion.FromArray([0,1,0,0]).multiply(u.Quaternion.FromArray(n)).asArray()))):n=u.Quaternion.Identity().asArray():(n=e.rotation.asArray(),p._GetRightHandedNormalArray3FromRef(n)):"translation"===t?(n=e.position.asArray(),r&&p._GetRightHandedPositionArray3FromRef(n)):n=e.scaling.asArray(),n}static _AddKeyframeValue(e,t,r,s,n,o,a){let i,l;const c=t.dataType;if(c===u.Animation.ANIMATIONTYPE_VECTOR3){if(i=e.value.asArray(),"rotation"===s){const e=u.Vector3.FromArray(i);let t=u.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z);o&&(p._GetRightHandedQuaternionFromRef(t),n.parent||(t=u.Quaternion.FromArray([0,1,0,0]).multiply(t))),i=t.asArray()}else"translation"===s&&o&&(p._GetRightHandedNormalArray3FromRef(i),n.parent||(i[0]*=-1,i[2]*=-1));r.push(i)}else if(c===u.Animation.ANIMATIONTYPE_FLOAT){if("weights"===s)r.push([e.value]);else if(l=this._ConvertFactorToVector3OrQuaternion(e.value,n,t,c,s,o,a),l){if("rotation"===s){let e=a?l:u.Quaternion.RotationYawPitchRoll(l.y,l.x,l.z).normalize();o&&(p._GetRightHandedQuaternionFromRef(e),n.parent||(e=u.Quaternion.FromArray([0,1,0,0]).multiply(e))),r.push(e.asArray())}else"translation"===s&&o&&(p._GetRightHandedNormalVector3FromRef(l),n.parent||(l.x*=-1,l.z*=-1));r.push(l.asArray())}}else c===u.Animation.ANIMATIONTYPE_QUATERNION?(i=e.value.normalize().asArray(),o&&(p._GetRightHandedQuaternionArrayFromRef(i),n.parent||(i=u.Quaternion.FromArray([0,1,0,0]).multiply(u.Quaternion.FromArray(i)).asArray())),r.push(i)):u.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(e,t,r){let s,n,o=!1;if("rotation"===t&&!r)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let t=0,r=e.length;t<r;++t)if(n=e[t],n.inTangent||n.outTangent)if(s){if("CUBICSPLINE"!==s){s="LINEAR",o=!0;break}}else s="CUBICSPLINE";else if(s){if("CUBICSPLINE"===s||n.interpolation&&n.interpolation===u.AnimationKeyInterpolation.STEP&&"STEP"!==s){s="LINEAR",o=!0;break}}else s=n.interpolation&&n.interpolation===u.AnimationKeyInterpolation.STEP?"STEP":"LINEAR";return s||(s="LINEAR"),{interpolationType:s,shouldBakeAnimation:o}}static AddSplineTangent(e,t,r,s,n,o,a,i,l){let c;const h=t===f.INTANGENT?o.inTangent:o.outTangent;if("CUBICSPLINE"===n){if("rotation"===s)if(h){if(i)c=h.asArray();else{const e=h;c=u.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).asArray()}l&&(p._GetRightHandedQuaternionArrayFromRef(c),e.parent||(c=u.Quaternion.FromArray([0,1,0,0]).multiply(u.Quaternion.FromArray(c)).asArray()))}else c=[0,0,0,0];else"weights"===s?c=h?[h]:[0]:h?(c=h.asArray(),l&&"translation"===s&&(p._GetRightHandedPositionArray3FromRef(c),e.parent||(c[0]*=-1,c[2]*=-1))):c=[0,0,0];r.push(c)}}static calculateMinMaxKeyFrames(e){let t=1/0,r=-1/0;return e.forEach((function(e){t=Math.min(t,e.frame),r=Math.max(r,e.frame)})),{min:t,max:r}}}class g{constructor(){this.glTFFiles={}}downloadFiles(){function e(e,t){return-1!==e.indexOf(t,e.length-t.length)}for(const t in this.glTFFiles){const r=document.createElement("a");document.body.appendChild(r),r.setAttribute("type","hidden"),r.download=t;const s=this.glTFFiles[t];let n;e(t,".glb")?n={type:"model/gltf-binary"}:e(t,".bin")?n={type:"application/octet-stream"}:e(t,".gltf")?n={type:"model/gltf+json"}:e(t,".jpeg")||e(t,".jpg")?n={type:"image/jpeg"}:e(t,".png")&&(n={type:"image/png"}),r.href=window.URL.createObjectURL(new Blob([s],n)),r.click()}}}class _{constructor(e){this._textureMap={},this._textureMap={},this._exporter=e}static FuzzyEquals(e,t,r){return u.Scalar.WithinEpsilon(e.r,t.r,r)&&u.Scalar.WithinEpsilon(e.g,t.g,r)&&u.Scalar.WithinEpsilon(e.b,t.b,r)}_convertMaterialsToGLTFAsync(e,t,r){const s=[];return e.forEach((e=>{"StandardMaterial"===e.getClassName()?s.push(this._convertStandardMaterialAsync(e,t,r)):-1!==e.getClassName().indexOf("PBR")?s.push(this._convertPBRMaterialAsync(e,t,r)):u.Tools.Warn(`Unsupported material type: ${e.name}`)})),Promise.all(s).then((()=>{}))}_stripTexturesFromMaterial(e){const t={};if(e){t.name=e.name,t.doubleSided=e.doubleSided,t.alphaMode=e.alphaMode,t.alphaCutoff=e.alphaCutoff,t.emissiveFactor=e.emissiveFactor;const r=e.pbrMetallicRoughness;r&&(t.pbrMetallicRoughness={},t.pbrMetallicRoughness.baseColorFactor=r.baseColorFactor,t.pbrMetallicRoughness.metallicFactor=r.metallicFactor,t.pbrMetallicRoughness.roughnessFactor=r.roughnessFactor)}return t}_hasTexturesPresent(e){var t;if(e.emissiveTexture||e.normalTexture||e.occlusionTexture)return!0;const r=e.pbrMetallicRoughness;if(r&&(r.baseColorTexture||r.metallicRoughnessTexture))return!0;if(e.extensions)for(const r in e.extensions){const s=e.extensions[r];if(s)return null===(t=s.hasTextures)||void 0===t?void 0:t.call(s)}return!1}_getTextureInfo(e){if(e){const t=e.uid;if(t in this._textureMap)return this._textureMap[t]}return null}_convertToGLTFPBRMetallicRoughness(e){const t=new u.Vector2(0,1),r=new u.Vector2(0,.1),s=new u.Vector2(0,.1),n=new u.Vector2(1300,.1),o=e.diffuseColor.toLinearSpace().scale(.5),a=e.alpha,i=(l=u.Scalar.Clamp(e.specularPower,0,_._MaxSpecularPower),c=Math.pow(l/n.x,.333333),h=t.y,f=r.y,d=s.y,p=n.y,(1-c)*(1-c)*(1-c)*h+3*(1-c)*(1-c)*c*f+3*(1-c)*c*c*d+c*c*c*p);var l,c,h,f,d,p;return{baseColorFactor:[o.r,o.g,o.b,a],metallicFactor:0,roughnessFactor:i}}static _SolveMetallic(e,t,r){if(t<this._DielectricSpecular.r)return this._DielectricSpecular,0;const s=this._DielectricSpecular.r,n=e*r/(1-this._DielectricSpecular.r)+t-2*this._DielectricSpecular.r,o=n*n-4*s*(this._DielectricSpecular.r-t);return u.Scalar.Clamp((-n+Math.sqrt(o))/(2*s),0,1)}static _SetAlphaMode(e,t){t.needAlphaBlending()?e.alphaMode="BLEND":t.needAlphaTesting()&&(e.alphaMode="MASK",e.alphaCutoff=t.alphaCutOff)}_convertStandardMaterialAsync(e,t,r){const s=this._exporter._materialMap,n=this._exporter._materials,o=[],a=this._convertToGLTFPBRMetallicRoughness(e),i={name:e.name};return null==e.backFaceCulling||e.backFaceCulling||(e.twoSidedLighting||u.Tools.Warn(e.name+": Back-face culling enabled and two-sided lighting disabled is not supported in glTF."),i.doubleSided=!0),r&&(e.diffuseTexture&&o.push(this._exportTextureAsync(e.diffuseTexture,t).then((e=>{e&&(a.baseColorTexture=e)}))),e.bumpTexture&&o.push(this._exportTextureAsync(e.bumpTexture,t).then((t=>{t&&(i.normalTexture=t,null!=e.bumpTexture&&1!==e.bumpTexture.level&&(i.normalTexture.scale=e.bumpTexture.level))}))),e.emissiveTexture&&(i.emissiveFactor=[1,1,1],o.push(this._exportTextureAsync(e.emissiveTexture,t).then((e=>{e&&(i.emissiveTexture=e)})))),e.ambientTexture&&o.push(this._exportTextureAsync(e.ambientTexture,t).then((e=>{if(e){const t={index:e.index};i.occlusionTexture=t,t.strength=1}})))),(e.alpha<1||e.opacityTexture)&&(e.alphaMode===u.Constants.ALPHA_COMBINE?i.alphaMode="BLEND":u.Tools.Warn(e.name+": glTF 2.0 does not support alpha mode: "+e.alphaMode.toString())),e.emissiveColor&&!_.FuzzyEquals(e.emissiveColor,u.Color3.Black(),_._Epsilon)&&(i.emissiveFactor=e.emissiveColor.asArray()),i.pbrMetallicRoughness=a,_._SetAlphaMode(i,e),n.push(i),s[e.uniqueId]=n.length-1,this._finishMaterial(o,i,e,t)}_finishMaterial(e,t,r,s){return Promise.all(e).then((()=>{const e=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",t,r);let n=null;for(const t of e)n||(n=[]),n.push(this._exportTextureAsync(t,s));return n||(n=[Promise.resolve(null)]),Promise.all(n).then((()=>{const e=this._exporter._extensionsPostExportMaterialAsync("exportMaterial",t,r);return e?e.then((()=>t)):t}))}))}_convertPBRMetallicRoughnessMaterialAsync(e,t,r){const s=this._exporter._materialMap,n=this._exporter._materials,o=[],a={};e.baseColor&&(a.baseColorFactor=[e.baseColor.r,e.baseColor.g,e.baseColor.b,e.alpha]),null!=e.metallic&&1!==e.metallic&&(a.metallicFactor=e.metallic),null!=e.roughness&&1!==e.roughness&&(a.roughnessFactor=e.roughness);const i={name:e.name};return e.doubleSided&&(i.doubleSided=e.doubleSided),_._SetAlphaMode(i,e),r&&(null!=e.baseTexture&&o.push(this._exportTextureAsync(e.baseTexture,t).then((e=>{e&&(a.baseColorTexture=e)}))),e.normalTexture&&o.push(this._exportTextureAsync(e.normalTexture,t).then((t=>{t&&(i.normalTexture=t,1!==e.normalTexture.level&&(i.normalTexture.scale=e.normalTexture.level))}))),e.occlusionTexture&&o.push(this._exportTextureAsync(e.occlusionTexture,t).then((t=>{t&&(i.occlusionTexture=t,null!=e.occlusionStrength&&(i.occlusionTexture.strength=e.occlusionStrength))}))),e.emissiveTexture&&o.push(this._exportTextureAsync(e.emissiveTexture,t).then((e=>{e&&(i.emissiveTexture=e)})))),_.FuzzyEquals(e.emissiveColor,u.Color3.Black(),_._Epsilon)&&(i.emissiveFactor=e.emissiveColor.asArray()),i.pbrMetallicRoughness=a,n.push(i),s[e.uniqueId]=n.length-1,this._finishMaterial(o,i,e,t)}_createBase64FromCanvasAsync(e,t,r,s){return new Promise((async(n,o)=>{const a=u.Constants.TEXTURETYPE_UNSIGNED_INT,i=this._exporter._babylonScene,l=i.getEngine(),c=l.createRawTexture(e,t,r,u.Constants.TEXTUREFORMAT_RGBA,!1,!0,u.Texture.NEAREST_SAMPLINGMODE,null,a);await u.TextureTools.ApplyPostProcess("pass",c,i,a,u.Constants.TEXTURE_NEAREST_SAMPLINGMODE,u.Constants.TEXTUREFORMAT_RGBA);const h=await l._readTexturePixels(c,t,r);n(await u.Tools.DumpDataAsync(t,r,h,s,void 0,!0,!1))}))}_createWhiteTexture(e,t,r){const s=new Uint8Array(e*t*4);for(let e=0;e<s.length;e+=4)s[e]=s[e+1]=s[e+2]=s[e+3]=255;return u.RawTexture.CreateRGBATexture(s,e,t,r)}_resizeTexturesToSameDimensions(e,t,r){const s=e?e.getSize():{width:0,height:0},n=t?t.getSize():{width:0,height:0};let o,a;return s.width<n.width?(o=e&&e instanceof u.Texture?u.TextureTools.CreateResizedCopy(e,n.width,n.height,!0):this._createWhiteTexture(n.width,n.height,r),a=t):s.width>n.width?(a=t&&t instanceof u.Texture?u.TextureTools.CreateResizedCopy(t,s.width,s.height,!0):this._createWhiteTexture(s.width,s.height,r),o=e):(o=e,a=t),{texture1:o,texture2:a}}_convertPixelArrayToFloat32(e){if(e instanceof Uint8Array){const t=e.length,r=new Float32Array(e.length);for(let s=0;s<t;++s)r[s]=e[s]/255;return r}if(e instanceof Float32Array)return e;throw new Error("Unsupported pixel format!")}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(e,t,r,s){var n;const o=[];if(!e&&!t)return Promise.reject("_ConvertSpecularGlosinessTexturesToMetallicRoughness: diffuse and specular glossiness textures are not defined!");const a=e?e.getScene():t?t.getScene():null;if(a){const i=this._resizeTexturesToSameDimensions(e,t,a),l=null===(n=i.texture1)||void 0===n?void 0:n.getSize();let c,h;const f=l.width,d=l.height,p=await i.texture1.readPixels(),m=await i.texture2.readPixels();if(!p)return Promise.reject("Failed to retrieve pixels from diffuse texture!");if(c=this._convertPixelArrayToFloat32(p),!m)return Promise.reject("Failed to retrieve pixels from specular glossiness texture!");h=this._convertPixelArrayToFloat32(m);const g=h.byteLength,x=new Uint8Array(g),T=new Uint8Array(g),y=4,A=u.Color3.Black();let b=0,F=0;for(let e=0;e<d;++e)for(let t=0;t<f;++t){const s=(f*e+t)*y,n={diffuseColor:new u.Color3(c[s],c[s+1],c[s+2]).toLinearSpace().multiply(r.diffuseColor),specularColor:new u.Color3(h[s],h[s+1],h[s+2]).toLinearSpace().multiply(r.specularColor),glossiness:h[s+3]*r.glossiness},o=this._convertSpecularGlossinessToMetallicRoughness(n);A.r=Math.max(A.r,o.baseColor.r),A.g=Math.max(A.g,o.baseColor.g),A.b=Math.max(A.b,o.baseColor.b),b=Math.max(b,o.metallic),F=Math.max(F,o.roughness),T[s]=255*o.baseColor.r,T[s+1]=255*o.baseColor.g,T[s+2]=255*o.baseColor.b,T[s+3]=i.texture1.hasAlpha?255*c[s+3]:255,x[s]=0,x[s+1]=255*o.roughness,x[s+2]=255*o.metallic,x[s+3]=255}const M={baseColor:A,metallic:b,roughness:F};let E=!1,R=!1;for(let e=0;e<d;++e)for(let t=0;t<f;++t){const r=(f*e+t)*y;T[r]/=M.baseColor.r>_._Epsilon?M.baseColor.r:1,T[r+1]/=M.baseColor.g>_._Epsilon?M.baseColor.g:1,T[r+2]/=M.baseColor.b>_._Epsilon?M.baseColor.b:1;const s=u.Color3.FromInts(T[r],T[r+1],T[r+2]).toGammaSpace();T[r]=255*s.r,T[r+1]=255*s.g,T[r+2]=255*s.b,_.FuzzyEquals(s,u.Color3.White(),_._Epsilon)||(R=!0),x[r+1]/=M.roughness>_._Epsilon?M.roughness:1,x[r+2]/=M.metallic>_._Epsilon?M.metallic:1;const n=u.Color3.FromInts(255,x[r+1],x[r+2]);_.FuzzyEquals(n,u.Color3.White(),_._Epsilon)||(E=!0)}if(E){const e=this._createBase64FromCanvasAsync(x,f,d,s).then((e=>{M.metallicRoughnessTextureBase64=e}));o.push(e)}if(R){const e=this._createBase64FromCanvasAsync(T,f,d,s).then((e=>{M.baseColorTextureBase64=e}));o.push(e)}return Promise.all(o).then((()=>M))}return Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(e){const t=this._getPerceivedBrightness(e.diffuseColor),r=this._getPerceivedBrightness(e.specularColor),s=1-this._getMaxComponent(e.specularColor),n=_._SolveMetallic(t,r,s),o=e.diffuseColor.scale(s/(1-_._DielectricSpecular.r)/Math.max(1-n,_._Epsilon)),a=e.specularColor.subtract(_._DielectricSpecular.scale(1-n)).scale(1/Math.max(n,_._Epsilon));let i=u.Color3.Lerp(o,a,n*n);return i=i.clampToRef(0,1,i),{baseColor:i,metallic:n,roughness:1-e.glossiness}}_getPerceivedBrightness(e){return e?Math.sqrt(.299*e.r*e.r+.587*e.g*e.g+.114*e.b*e.b):0}_getMaxComponent(e){return e?Math.max(e.r,Math.max(e.g,e.b)):0}_convertMetalRoughFactorsToMetallicRoughnessAsync(e,t,r,s){const n=[],o={baseColor:e._albedoColor,metallic:e._metallic,roughness:e._roughness};if(s){e._albedoTexture&&n.push(this._exportTextureAsync(e._albedoTexture,t).then((e=>{e&&(r.baseColorTexture=e)})));const s=e._metallicTexture;s&&n.push(this._exportTextureAsync(s,t).then((e=>{e&&(r.metallicRoughnessTexture=e)})))}return Promise.all(n).then((()=>o))}_getGLTFTextureSampler(e){const t=this._getGLTFTextureWrapModesSampler(e),r=e instanceof u.Texture?e.samplingMode:null;if(null!=r)switch(r){case u.Texture.LINEAR_LINEAR:t.magFilter=9729,t.minFilter=9729;break;case u.Texture.LINEAR_NEAREST:t.magFilter=9729,t.minFilter=9728;break;case u.Texture.NEAREST_LINEAR:t.magFilter=9728,t.minFilter=9729;break;case u.Texture.NEAREST_LINEAR_MIPLINEAR:t.magFilter=9728,t.minFilter=9987;break;case u.Texture.NEAREST_NEAREST:t.magFilter=9728,t.minFilter=9728;break;case u.Texture.NEAREST_LINEAR_MIPNEAREST:t.magFilter=9728,t.minFilter=9985;break;case u.Texture.LINEAR_NEAREST_MIPNEAREST:t.magFilter=9729,t.minFilter=9984;break;case u.Texture.LINEAR_NEAREST_MIPLINEAR:t.magFilter=9729,t.minFilter=9986;break;case u.Texture.NEAREST_NEAREST_MIPLINEAR:t.magFilter=9728,t.minFilter=9986;break;case u.Texture.LINEAR_LINEAR_MIPLINEAR:t.magFilter=9729,t.minFilter=9987;break;case u.Texture.LINEAR_LINEAR_MIPNEAREST:t.magFilter=9729,t.minFilter=9985;break;case u.Texture.NEAREST_NEAREST_MIPNEAREST:t.magFilter=9728,t.minFilter=9984}return t}_getGLTFTextureWrapMode(e){switch(e){case u.Texture.WRAP_ADDRESSMODE:return 10497;case u.Texture.CLAMP_ADDRESSMODE:return 33071;case u.Texture.MIRROR_ADDRESSMODE:return 33648;default:return u.Tools.Error(`Unsupported Texture Wrap Mode ${e}!`),10497}}_getGLTFTextureWrapModesSampler(e){const t=this._getGLTFTextureWrapMode(e instanceof u.Texture?e.wrapU:u.Texture.WRAP_ADDRESSMODE),r=this._getGLTFTextureWrapMode(e instanceof u.Texture?e.wrapV:u.Texture.WRAP_ADDRESSMODE);return 10497===t&&10497===r?{}:{wrapS:t,wrapT:r}}_convertSpecGlossFactorsToMetallicRoughnessAsync(e,t,r,s){return Promise.resolve().then((()=>{const n=this._exporter._samplers,o=this._exporter._textures,a={diffuseColor:e._albedoColor,specularColor:e._reflectivityColor,glossiness:e._microSurface};let i=null;const l=e._albedoTexture,c=e._reflectivityTexture;if(l){const e=this._getGLTFTextureSampler(l);null!=e.magFilter&&null!=e.minFilter&&null!=e.wrapS&&null!=e.wrapT&&(n.push(e),i=n.length-1)}const u=e._useMicroSurfaceFromReflectivityMapAlpha;return c&&!u?Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported"):(l||c)&&s?this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(l,c,a,t).then((e=>{if(e.baseColorTextureBase64){const s=this._getTextureInfoFromBase64(e.baseColorTextureBase64,"bjsBaseColorTexture_"+o.length+".png",t,l?l.coordinatesIndex:null,i);s&&(r.baseColorTexture=s)}if(e.metallicRoughnessTextureBase64){const s=this._getTextureInfoFromBase64(e.metallicRoughnessTextureBase64,"bjsMetallicRoughnessTexture_"+o.length+".png",t,c?c.coordinatesIndex:null,i);s&&(r.metallicRoughnessTexture=s)}return e})):this._convertSpecularGlossinessToMetallicRoughness(a)}))}_convertPBRMaterialAsync(e,t,r){const s={},n={name:e.name};if(e.isMetallicWorkflow()){const o=e._albedoColor,a=e.alpha;return o&&(s.baseColorFactor=[o.r,o.g,o.b,a]),this._convertMetalRoughFactorsToMetallicRoughnessAsync(e,t,s,r).then((o=>this.setMetallicRoughnessPbrMaterial(o,e,n,s,t,r)))}return this._convertSpecGlossFactorsToMetallicRoughnessAsync(e,t,s,r).then((o=>this.setMetallicRoughnessPbrMaterial(o,e,n,s,t,r)))}setMetallicRoughnessPbrMaterial(e,t,r,s,n,o){const a=this._exporter._materialMap,i=this._exporter._materials,l=[];if(e){if(_._SetAlphaMode(r,t),_.FuzzyEquals(e.baseColor,u.Color3.White(),_._Epsilon)&&t.alpha>=_._Epsilon||(s.baseColorFactor=[e.baseColor.r,e.baseColor.g,e.baseColor.b,t.alpha]),null!=e.metallic&&1!==e.metallic&&(s.metallicFactor=e.metallic),null!=e.roughness&&1!==e.roughness&&(s.roughnessFactor=e.roughness),null==t.backFaceCulling||t.backFaceCulling||(t._twoSidedLighting||u.Tools.Warn(t.name+": Back-face culling enabled and two-sided lighting disabled is not supported in glTF."),r.doubleSided=!0),o){const e=t._bumpTexture;if(e){const t=this._exportTextureAsync(e,n).then((t=>{t&&(r.normalTexture=t,1!==e.level&&(r.normalTexture.scale=e.level))}));l.push(t)}const s=t._ambientTexture;if(s){const e=this._exportTextureAsync(s,n).then((e=>{if(e){const s={index:e.index,texCoord:e.texCoord};r.occlusionTexture=s;const n=t._ambientTextureStrength;n&&(s.strength=n)}}));l.push(e)}const o=t._emissiveTexture;if(o){const e=this._exportTextureAsync(o,n).then((e=>{e&&(r.emissiveTexture=e)}));l.push(e)}}const c=t._emissiveColor;_.FuzzyEquals(c,u.Color3.Black(),_._Epsilon)||(r.emissiveFactor=c.asArray()),r.pbrMetallicRoughness=s,i.push(r),a[t.uniqueId]=i.length-1}return this._finishMaterial(l,r,t,n)}getPixelsFromTexture(e){return e.textureType,u.Constants.TEXTURETYPE_UNSIGNED_INT,e.readPixels()}_exportTextureAsync(e,t){const r=this._exporter._extensionsPreExportTextureAsync("exporter",e,t);return r?r.then((r=>r?this._exportTextureInfoAsync(r,t):this._exportTextureInfoAsync(e,t))):this._exportTextureInfoAsync(e,t)}_exportTextureInfoAsync(e,t){return Promise.resolve().then((async()=>{const r=e.uid;if(r in this._textureMap)return this._textureMap[r];{const s=await this.getPixelsFromTexture(e);if(!s)return null;const n=this._exporter._samplers,o=this._getGLTFTextureSampler(e);let a=null,i=null;for(let e=0;e<n.length;++e){const t=n[e];if(t.minFilter===o.minFilter&&t.magFilter===o.magFilter&&t.wrapS===o.wrapS&&t.wrapT===o.wrapT){i=e;break}}null==i?(n.push(o),a=n.length-1):a=i;const l=e.getSize();if(e.mimeType)switch(e.mimeType){case"image/jpeg":t="image/jpeg";break;case"image/png":t="image/png"}return this._createBase64FromCanvasAsync(s,l.width,l.height,t).then((s=>{const n=this._getTextureInfoFromBase64(s,e.name.replace(/\.\/|\/|\.\\|\\/g,"_"),t,e.coordinatesIndex,a);return n&&(this._textureMap[r]=n,this._exporter._extensionsPostExportTextures("linkTextureInfo",n,e)),n}))}}))}_getTextureInfoFromBase64(e,t,r,s,n){const o=this._exporter._textures,a=this._exporter._images,i=this._exporter._imageData;let l=null;const c={source:a.length,name:t};null!=n&&(c.sampler=n);const h=atob(e.split(",")[1]),f=new ArrayBuffer(h.length),d=new Uint8Array(f);for(let e=0,t=h.length;e<t;++e)d[e]=h.charCodeAt(e);const p={data:d,mimeType:r},m="image/jpeg"===r?".jpeg":".png";let g=t+m;const _=g;if(g in i&&(g=`${t}_${u.Tools.RandomId()}${m}`),i[g]=p,"image/jpeg"===r||"image/png"===r){const e={name:t,uri:g};let r=null;for(let e=0;e<a.length;++e)if(a[e].uri===_){r=e;break}null==r?(a.push(e),c.source=a.length-1):c.source=r,o.push(c),l={index:o.length-1},null!=s&&(l.texCoord=s)}else u.Tools.Error(`Unsupported texture mime type ${r}`);return l}}_._DielectricSpecular=new u.Color3(.04,.04,.04),_._MaxSpecularPower=1024,_._Epsilon=1e-6;class x{constructor(e,t){this._includeCoordinateSystemConversionNodes=!1,this._extensions={},this._glTF={asset:{generator:"BabylonJS",version:"2.0"}},(e=e||u.EngineStore.LastCreatedScene)&&(this._babylonScene=e,this._bufferViews=[],this._accessors=[],this._meshes=[],this._scenes=[],this._cameras=[],this._nodes=[],this._images=[],this._materials=[],this._materialMap=[],this._textures=[],this._samplers=[],this._skins=[],this._animations=[],this._imageData={},this._orderedImageData=[],this._options=t||{},this._animationSampleRate=t&&t.animationSampleRate?t.animationSampleRate:1/60,this._includeCoordinateSystemConversionNodes=!(!t||!t.includeCoordinateSystemConversionNodes),this._glTFMaterialExporter=new _(this),this._loadExtensions())}_applyExtension(e,t,r,s){if(r>=t.length)return Promise.resolve(e);const n=s(t[r],e);return n?n.then((e=>this._applyExtension(e,t,r+1,s))):this._applyExtension(e,t,r+1,s)}_applyExtensions(e,t){const r=[];for(const e of x._ExtensionNames)r.push(this._extensions[e]);return this._applyExtension(e,r,0,t)}_extensionsPreExportTextureAsync(e,t,r){return this._applyExtensions(t,((t,s)=>t.preExportTextureAsync&&t.preExportTextureAsync(e,s,r)))}_extensionsPostExportMeshPrimitiveAsync(e,t,r,s){return this._applyExtensions(t,((t,n)=>t.postExportMeshPrimitiveAsync&&t.postExportMeshPrimitiveAsync(e,n,r,s)))}_extensionsPostExportNodeAsync(e,t,r,s){return this._applyExtensions(t,((t,n)=>t.postExportNodeAsync&&t.postExportNodeAsync(e,n,r,s)))}_extensionsPostExportMaterialAsync(e,t,r){return this._applyExtensions(t,((t,s)=>t.postExportMaterialAsync&&t.postExportMaterialAsync(e,s,r)))}_extensionsPostExportMaterialAdditionalTextures(e,t,r){const s=[];for(const n of x._ExtensionNames){const o=this._extensions[n];o.postExportMaterialAdditionalTextures&&s.push(...o.postExportMaterialAdditionalTextures(e,t,r))}return s}_extensionsPostExportTextures(e,t,r){for(const s of x._ExtensionNames){const n=this._extensions[s];n.postExportTexture&&n.postExportTexture(e,t,r)}}_forEachExtensions(e){for(const t of x._ExtensionNames){const r=this._extensions[t];r.enabled&&e(r)}}_extensionsOnExporting(){this._forEachExtensions((e=>{e.wasUsed&&(null==this._glTF.extensionsUsed&&(this._glTF.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(e.name)&&this._glTF.extensionsUsed.push(e.name),e.required&&(null==this._glTF.extensionsRequired&&(this._glTF.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(e.name)&&this._glTF.extensionsRequired.push(e.name)),null==this._glTF.extensions&&(this._glTF.extensions={}),e.onExporting&&e.onExporting())}))}_loadExtensions(){for(const e of x._ExtensionNames){const t=x._ExtensionFactories[e](this);this._extensions[e]=t}}dispose(){for(const e in this._extensions)this._extensions[e].dispose()}static RegisterExtension(e,t){x.UnregisterExtension(e)&&u.Tools.Warn(`Extension with the name ${e} already exists`),x._ExtensionFactories[e]=t,x._ExtensionNames.push(e)}static UnregisterExtension(e){if(!x._ExtensionFactories[e])return!1;delete x._ExtensionFactories[e];const t=x._ExtensionNames.indexOf(e);return-1!==t&&x._ExtensionNames.splice(t,1),!0}reorderIndicesBasedOnPrimitiveMode(e,t,r,s,n){switch(t){case u.Material.TriangleFillMode:s||(s=0);for(let t=e.indexStart,r=e.indexStart+e.indexCount;t<r;t+=3){const e=s+4*t,r=n.getUInt32(e+4),o=n.getUInt32(e+8);n.setUInt32(o,e+4),n.setUInt32(r,e+8)}break;case u.Material.TriangleFanDrawMode:for(let t=e.indexStart+e.indexCount-1,o=e.indexStart;t>=o;--t)n.setUInt32(r[t],s),s+=4;break;case u.Material.TriangleStripDrawMode:e.indexCount>=3&&(n.setUInt32(r[e.indexStart+2],s+4),n.setUInt32(r[e.indexStart+1],s+8))}}reorderVertexAttributeDataBasedOnPrimitiveMode(e,t,r,s,n,o,a,i){if(i&&r===u.Material.ClockWiseSideOrientation)switch(t){case u.Material.TriangleFillMode:this.reorderTriangleFillMode(e,t,r,s,n,o,a,i);break;case u.Material.TriangleStripDrawMode:this.reorderTriangleStripDrawMode(e,t,r,s,n,o,a,i);break;case u.Material.TriangleFanDrawMode:this.reorderTriangleFanMode(e,t,r,s,n,o,a,i)}}reorderTriangleFillMode(e,t,r,s,n,o,a,i){const l=this.getVertexBufferFromMesh(s,e.getMesh());if(l){const t=l.byteStride/u.VertexBuffer.GetTypeByteLength(l.type);if(e.verticesCount%3!=0)u.Tools.Error("The submesh vertices for the triangle fill mode is not divisible by 3!");else{const r=[];let c=0;switch(s){case u.VertexBuffer.PositionKind:case u.VertexBuffer.NormalKind:for(let s=e.verticesStart;s<e.verticesStart+e.verticesCount;s+=3)c=s*t,r.push(u.Vector3.FromArray(n,c)),r.push(u.Vector3.FromArray(n,c+2*t)),r.push(u.Vector3.FromArray(n,c+t));break;case u.VertexBuffer.TangentKind:for(let s=e.verticesStart;s<e.verticesStart+e.verticesCount;s+=3)c=s*t,r.push(u.Vector4.FromArray(n,c)),r.push(u.Vector4.FromArray(n,c+2*t)),r.push(u.Vector4.FromArray(n,c+t));break;case u.VertexBuffer.ColorKind:{const s=l.getSize();for(let o=e.verticesStart;o<e.verticesStart+e.verticesCount;o+=s)c=o*t,4===s?(r.push(u.Vector4.FromArray(n,c)),r.push(u.Vector4.FromArray(n,c+2*t)),r.push(u.Vector4.FromArray(n,c+t))):(r.push(u.Vector3.FromArray(n,c)),r.push(u.Vector3.FromArray(n,c+2*t)),r.push(u.Vector3.FromArray(n,c+t)));break}case u.VertexBuffer.UVKind:case u.VertexBuffer.UV2Kind:for(let s=e.verticesStart;s<e.verticesStart+e.verticesCount;s+=3)c=s*t,r.push(u.Vector2.FromArray(n,c)),r.push(u.Vector2.FromArray(n,c+2*t)),r.push(u.Vector2.FromArray(n,c+t));break;default:u.Tools.Error(`Unsupported Vertex Buffer type: ${s}`)}this.writeVertexAttributeData(r,o,s,n,a,i)}}else u.Tools.Warn(`reorderTriangleFillMode: Vertex Buffer Kind ${s} not present!`)}reorderTriangleStripDrawMode(e,t,r,s,n,o,a,i){const l=this.getVertexBufferFromMesh(s,e.getMesh());if(l){const t=l.byteStride/u.VertexBuffer.GetTypeByteLength(l.type),r=[];let c=0;switch(s){case u.VertexBuffer.PositionKind:case u.VertexBuffer.NormalKind:c=e.verticesStart,r.push(u.Vector3.FromArray(n,c+2*t)),r.push(u.Vector3.FromArray(n,c+t));break;case u.VertexBuffer.TangentKind:for(let s=e.verticesStart+e.verticesCount-1;s>=e.verticesStart;--s)c=s*t,r.push(u.Vector4.FromArray(n,c));break;case u.VertexBuffer.ColorKind:for(let s=e.verticesStart+e.verticesCount-1;s>=e.verticesStart;--s)c=s*t,4===l.getSize()?r.push(u.Vector4.FromArray(n,c)):r.push(u.Vector3.FromArray(n,c));break;case u.VertexBuffer.UVKind:case u.VertexBuffer.UV2Kind:for(let s=e.verticesStart+e.verticesCount-1;s>=e.verticesStart;--s)c=s*t,r.push(u.Vector2.FromArray(n,c));break;default:u.Tools.Error(`Unsupported Vertex Buffer type: ${s}`)}this.writeVertexAttributeData(r,o+12,s,n,a,i)}else u.Tools.Warn(`reorderTriangleStripDrawMode: Vertex buffer kind ${s} not present!`)}reorderTriangleFanMode(e,t,r,s,n,o,a,i){const l=this.getVertexBufferFromMesh(s,e.getMesh());if(l){const t=l.byteStride/u.VertexBuffer.GetTypeByteLength(l.type),r=[];let c=0;switch(s){case u.VertexBuffer.PositionKind:case u.VertexBuffer.NormalKind:for(let s=e.verticesStart+e.verticesCount-1;s>=e.verticesStart;--s)c=s*t,r.push(u.Vector3.FromArray(n,c));break;case u.VertexBuffer.TangentKind:for(let s=e.verticesStart+e.verticesCount-1;s>=e.verticesStart;--s)c=s*t,r.push(u.Vector4.FromArray(n,c));break;case u.VertexBuffer.ColorKind:for(let s=e.verticesStart+e.verticesCount-1;s>=e.verticesStart;--s)c=s*t,r.push(u.Vector4.FromArray(n,c)),4===l.getSize()?r.push(u.Vector4.FromArray(n,c)):r.push(u.Vector3.FromArray(n,c));break;case u.VertexBuffer.UVKind:case u.VertexBuffer.UV2Kind:for(let s=e.verticesStart+e.verticesCount-1;s>=e.verticesStart;--s)c=s*t,r.push(u.Vector2.FromArray(n,c));break;default:u.Tools.Error(`Unsupported Vertex Buffer type: ${s}`)}this.writeVertexAttributeData(r,o,s,n,a,i)}else u.Tools.Warn(`reorderTriangleFanMode: Vertex buffer kind ${s} not present!`)}writeVertexAttributeData(e,t,r,s,n,o){for(const s of e){!o||r===u.VertexBuffer.ColorKind||s instanceof u.Vector2||(s instanceof u.Vector3?r===u.VertexBuffer.NormalKind?p._GetRightHandedNormalVector3FromRef(s):r===u.VertexBuffer.PositionKind?p._GetRightHandedPositionVector3FromRef(s):u.Tools.Error("Unsupported vertex attribute kind!"):p._GetRightHandedVector4FromRef(s)),r===u.VertexBuffer.NormalKind?s.normalize():r===u.VertexBuffer.TangentKind&&s instanceof u.Vector4&&p._NormalizeTangentFromRef(s);for(const e of s.asArray())n.setFloat32(e,t),t+=4}}writeAttributeData(e,t,r,s,n,o,a){let i,l,c=[];switch(e){case u.VertexBuffer.PositionKind:for(let e=0,t=r.length/s;e<t;++e){i=e*s;const t=u.Vector3.FromArray(r,i);o&&p._GetRightHandedPositionVector3FromRef(t),c.push(t.asArray())}break;case u.VertexBuffer.NormalKind:for(let e=0,t=r.length/s;e<t;++e){i=e*s;const t=u.Vector3.FromArray(r,i);o&&p._GetRightHandedNormalVector3FromRef(t),t.normalize(),c.push(t.asArray())}break;case u.VertexBuffer.TangentKind:for(let e=0,t=r.length/s;e<t;++e){i=e*s;const t=u.Vector4.FromArray(r,i);o&&p._GetRightHandedVector4FromRef(t),p._NormalizeTangentFromRef(t),c.push(t.asArray())}break;case u.VertexBuffer.ColorKind:{const e=a.material,t=!e||"StandardMaterial"===e.getClassName(),n=3===s?new u.Color3:new u.Color4;for(let e=0,o=r.length/s;e<o;++e)i=e*s,3===s?(u.Color3.FromArrayToRef(r,i,n),t&&n.toLinearSpaceToRef(n)):(u.Color4.FromArrayToRef(r,i,n),t&&n.toLinearSpaceToRef(n)),c.push(n.asArray());break}case u.VertexBuffer.UVKind:case u.VertexBuffer.UV2Kind:for(let e=0,t=r.length/s;e<t;++e)i=e*s,c.push([r[i],r[i+1]]);break;case u.VertexBuffer.MatricesIndicesKind:case u.VertexBuffer.MatricesIndicesExtraKind:for(let e=0,t=r.length/s;e<t;++e){i=e*s;const t=u.Vector4.FromArray(r,i);c.push(t.asArray())}break;case u.VertexBuffer.MatricesWeightsKind:case u.VertexBuffer.MatricesWeightsExtraKind:for(let e=0,t=r.length/s;e<t;++e){i=e*s;const t=u.Vector4.FromArray(r,i);c.push(t.asArray())}break;default:u.Tools.Warn("Unsupported Vertex Buffer Type: "+e),c=[]}switch(t){case 5121:l=n.setUInt8.bind(n);break;case 5123:l=n.setUInt16.bind(n);break;case 5125:l=n.setUInt32.bind(n);case 5126:l=n.setFloat32.bind(n);break;default:return void u.Tools.Warn("Unsupported Attribute Component kind: "+t)}for(const e of c)for(const t of e)l(t)}writeMorphTargetAttributeData(e,t,r,s,n,o,a,i,l,c){let h,f,d=[],m=new u.Vector3,g=new u.Vector4(0,0,0,0);switch(e){case u.VertexBuffer.PositionKind:for(let e=r.verticesStart;e<r.verticesCount;++e){h=r.indexStart+e*a;const t=u.Vector3.FromArray(n,h);m=u.Vector3.FromArray(o,h).subtractToRef(t,m),l&&p._GetRightHandedPositionVector3FromRef(m),c&&(c.min.copyFromFloats(Math.min(m.x,c.min.x),Math.min(m.y,c.min.y),Math.min(m.z,c.min.z)),c.max.copyFromFloats(Math.max(m.x,c.max.x),Math.max(m.y,c.max.y),Math.max(m.z,c.max.z))),d.push(m.asArray())}break;case u.VertexBuffer.NormalKind:for(let e=r.verticesStart;e<r.verticesCount;++e){h=r.indexStart+e*a;const t=u.Vector3.FromArray(n,h);t.normalize();const s=u.Vector3.FromArray(o,h);s.normalize(),m=s.subtractToRef(t,m),l&&p._GetRightHandedNormalVector3FromRef(m),d.push(m.asArray())}break;case u.VertexBuffer.TangentKind:for(let e=r.verticesStart;e<r.verticesCount;++e){h=r.indexStart+e*(a+1);const t=u.Vector4.FromArray(n,h);p._NormalizeTangentFromRef(t);const s=u.Vector4.FromArray(o,h);p._NormalizeTangentFromRef(s),g=s.subtractToRef(t,g),l&&p._GetRightHandedVector4FromRef(g),d.push([g.x,g.y,g.z])}break;default:u.Tools.Warn("Unsupported Vertex Buffer Type: "+e),d=[]}switch(t){case 5121:f=i.setUInt8.bind(i);break;case 5123:f=i.setUInt16.bind(i);break;case 5125:f=i.setUInt32.bind(i);case 5126:f=i.setFloat32.bind(i);break;default:return void u.Tools.Warn("Unsupported Attribute Component kind: "+t)}for(const e of d)for(const t of e)f(t)}generateJSON(e,t,r){const s={byteLength:this._totalByteLength};let n,o,a,i=this._totalByteLength;return s.byteLength&&(this._glTF.buffers=[s]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.scene=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(e?(this._glTF.images=[],this._images.forEach((e=>{e.uri&&(o=this._imageData[e.uri],this._orderedImageData.push(o),n=e.uri.split(".")[0]+" image",a=p._CreateBufferView(0,i,o.data.length,void 0,n),i+=o.data.buffer.byteLength,this._bufferViews.push(a),e.bufferView=this._bufferViews.length-1,e.name=n,e.mimeType=o.mimeType,e.uri=void 0,this._glTF.images||(this._glTF.images=[]),this._glTF.images.push(e))})),s.byteLength=i):this._glTF.images=this._images),e||(s.uri=t+".bin"),r?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}_generateGLTFAsync(e,t=!0){return this._generateBinaryAsync().then((r=>{this._extensionsOnExporting();const s=this.generateJSON(!1,e,!0),n=new Blob([r],{type:"application/octet-stream"}),o=e+".gltf",a=e+".bin",i=new g;if(i.glTFFiles[o]=s,i.glTFFiles[a]=n,this._imageData)for(const e in this._imageData)i.glTFFiles[e]=new Blob([this._imageData[e].data],{type:this._imageData[e].mimeType});return t&&this.dispose(),i}))}_generateBinaryAsync(){const e=new T(4);return this.createSceneAsync(this._babylonScene,e).then((()=>(this._localEngine&&this._localEngine.dispose(),e.getArrayBuffer())))}_getPadding(e){const t=e%4;return 0===t?t:4-t}_generateGLBAsync(e,t=!0){return this._generateBinaryAsync().then((r=>{this._extensionsOnExporting();const s=this.generateJSON(!0),n=e+".glb";let o,a=s.length,i=0;"undefined"!=typeof TextEncoder&&(o=(new TextEncoder).encode(s),a=o.length);for(let e=0;e<this._orderedImageData.length;++e)i+=this._orderedImageData[e].data.byteLength;const l=this._getPadding(a),c=this._getPadding(r.byteLength),u=this._getPadding(i),h=28+a+l+r.byteLength+c+i+u,f=new ArrayBuffer(12),d=new DataView(f);d.setUint32(0,1179937895,!0),d.setUint32(4,2,!0),d.setUint32(8,h,!0);const p=new ArrayBuffer(8+a+l),m=new DataView(p);m.setUint32(0,a+l,!0),m.setUint32(4,1313821514,!0);const _=new Uint8Array(p,8);if(o)_.set(o);else{const e="_".charCodeAt(0);for(let t=0;t<a;++t){const r=s.charCodeAt(t);r!=s.codePointAt(t)?_[t]=e:_[t]=r}}const x=new Uint8Array(p,8+a);for(let e=0;e<l;++e)x[e]=32;const T=new ArrayBuffer(8),y=new DataView(T);y.setUint32(0,r.byteLength+i+u,!0),y.setUint32(4,5130562,!0);const A=new ArrayBuffer(c),b=new Uint8Array(A);for(let e=0;e<c;++e)b[e]=0;const F=new ArrayBuffer(u),M=new Uint8Array(F);for(let e=0;e<u;++e)M[e]=0;const E=[f,p,T,r];for(let e=0;e<this._orderedImageData.length;++e)E.push(this._orderedImageData[e].data.buffer);E.push(A),E.push(F);const R=new Blob(E,{type:"application/octet-stream"}),C=new g;return C.glTFFiles[n]=R,null!=this._localEngine&&this._localEngine.dispose(),t&&this.dispose(),C}))}setNodeTransformation(e,t,r){t.getPivotPoint().equalsToFloats(0,0,0)||u.Tools.Warn("Pivot points are not supported in the glTF serializer"),t.position.equalsToFloats(0,0,0)||(e.translation=r?p._GetRightHandedPositionVector3(t.position).asArray():t.position.asArray()),t.scaling.equalsToFloats(1,1,1)||(e.scale=t.scaling.asArray());const s=u.Quaternion.RotationYawPitchRoll(t.rotation.y,t.rotation.x,t.rotation.z);t.rotationQuaternion&&s.multiplyInPlace(t.rotationQuaternion),u.Quaternion.IsIdentity(s)||(r&&p._GetRightHandedQuaternionFromRef(s),e.rotation=s.normalize().asArray())}setCameraTransformation(e,t,r){t.position.equalsToFloats(0,0,0)||(e.translation=r?p._GetRightHandedPositionVector3(t.position).asArray():t.position.asArray());const s=t.absoluteRotation;u.Quaternion.IsIdentity(s)||(r&&p._GetRightHandedQuaternionFromRef(s),e.rotation=s.normalize().asArray())}getVertexBufferFromMesh(e,t){if(t.isVerticesDataPresent(e)){const r=t.getVertexBuffer(e);if(r)return r}return null}createBufferViewKind(e,t,r,s,n,o){const a=r instanceof u.Mesh?r:r instanceof u.InstancedMesh?r.sourceMesh:null;if(a){const i=a.getVertexBuffer(e),l=a.getVerticesData(e);if(i&&l){const i=u.VertexBuffer.GetTypeByteLength(t),c=l.length*i,h=p._CreateBufferView(0,s.getByteOffset(),c,n,e+" - "+a.name);this._bufferViews.push(h),this.writeAttributeData(e,t,l,n/i,s,o,r)}}}setMorphTargetAttributes(e,t,r,s,n){if(r){t.targets||(t.targets=[]);const o={};if(r.hasNormals){const t=e.getMesh().getVerticesData(u.VertexBuffer.NormalKind),a=r.getNormals(),i=e.verticesCount,l=12,c=i*l,h=p._CreateBufferView(0,s.getByteOffset(),c,l,r.name+"_NORMAL");this._bufferViews.push(h);const f=this._bufferViews.length-1,d=p._CreateAccessor(f,r.name+" - NORMAL","VEC3",5126,i,0,null,null);this._accessors.push(d),o.NORMAL=this._accessors.length-1,this.writeMorphTargetAttributeData(u.VertexBuffer.NormalKind,5126,e,r,t,a,l/4,s,n)}if(r.hasPositions){const t=e.getMesh().getVerticesData(u.VertexBuffer.PositionKind),a=r.getPositions(),i=e.verticesCount,l=12,c=i*l,h=p._CreateBufferView(0,s.getByteOffset(),c,l,r.name+"_POSITION");this._bufferViews.push(h);const f=this._bufferViews.length-1,d={min:new u.Vector3(1/0,1/0,1/0),max:new u.Vector3(-1/0,-1/0,-1/0)},m=p._CreateAccessor(f,r.name+" - POSITION","VEC3",5126,i,0,null,null);this._accessors.push(m),o.POSITION=this._accessors.length-1,this.writeMorphTargetAttributeData(u.VertexBuffer.PositionKind,5126,e,r,t,a,l/4,s,n,d),m.min=d.min.asArray(),m.max=d.max.asArray()}if(r.hasTangents){const t=e.getMesh().getVerticesData(u.VertexBuffer.TangentKind),a=r.getTangents(),i=e.verticesCount,l=12,c=i*l,h=p._CreateBufferView(0,s.getByteOffset(),c,l,r.name+"_NORMAL");this._bufferViews.push(h);const f=this._bufferViews.length-1,d=p._CreateAccessor(f,r.name+" - TANGENT","VEC3",5126,i,0,null,null);this._accessors.push(d),o.TANGENT=this._accessors.length-1,this.writeMorphTargetAttributeData(u.VertexBuffer.TangentKind,5126,e,r,t,a,l/4,s,n)}t.targets.push(o)}}getMeshPrimitiveMode(e){return e instanceof u.LinesMesh?u.Material.LineListDrawMode:e.material?e.material.fillMode:u.Material.TriangleFillMode}setPrimitiveMode(e,t){switch(t){case u.Material.TriangleFillMode:break;case u.Material.TriangleStripDrawMode:e.mode=5;break;case u.Material.TriangleFanDrawMode:e.mode=6;break;case u.Material.PointListDrawMode:e.mode=0;case u.Material.PointFillMode:e.mode=0;break;case u.Material.LineLoopDrawMode:e.mode=2;break;case u.Material.LineListDrawMode:e.mode=1;break;case u.Material.LineStripDrawMode:e.mode=3}}setAttributeKind(e,t){switch(t){case u.VertexBuffer.PositionKind:e.attributes.POSITION=this._accessors.length-1;break;case u.VertexBuffer.NormalKind:e.attributes.NORMAL=this._accessors.length-1;break;case u.VertexBuffer.ColorKind:e.attributes.COLOR_0=this._accessors.length-1;break;case u.VertexBuffer.TangentKind:e.attributes.TANGENT=this._accessors.length-1;break;case u.VertexBuffer.UVKind:e.attributes.TEXCOORD_0=this._accessors.length-1;break;case u.VertexBuffer.UV2Kind:e.attributes.TEXCOORD_1=this._accessors.length-1;break;case u.VertexBuffer.MatricesIndicesKind:e.attributes.JOINTS_0=this._accessors.length-1;break;case u.VertexBuffer.MatricesIndicesExtraKind:e.attributes.JOINTS_1=this._accessors.length-1;break;case u.VertexBuffer.MatricesWeightsKind:e.attributes.WEIGHTS_0=this._accessors.length-1;break;case u.VertexBuffer.MatricesWeightsExtraKind:e.attributes.WEIGHTS_1=this._accessors.length-1;break;default:u.Tools.Warn("Unsupported Vertex Buffer Type: "+t)}}setPrimitiveAttributesAsync(e,t,r,s){var n;const o=[];let a,i,l=null;t instanceof u.Mesh?l=t:t instanceof u.InstancedMesh&&(l=t.sourceMesh);const c=[{kind:u.VertexBuffer.PositionKind,accessorType:"VEC3",accessorComponentType:5126,byteStride:12},{kind:u.VertexBuffer.NormalKind,accessorType:"VEC3",accessorComponentType:5126,byteStride:12},{kind:u.VertexBuffer.ColorKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16},{kind:u.VertexBuffer.TangentKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16},{kind:u.VertexBuffer.UVKind,accessorType:"VEC2",accessorComponentType:5126,byteStride:8},{kind:u.VertexBuffer.UV2Kind,accessorType:"VEC2",accessorComponentType:5126,byteStride:8},{kind:u.VertexBuffer.MatricesIndicesKind,accessorType:"VEC4",accessorComponentType:5123,byteStride:8},{kind:u.VertexBuffer.MatricesIndicesExtraKind,accessorType:"VEC4",accessorComponentType:5123,byteStride:8},{kind:u.VertexBuffer.MatricesWeightsKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16},{kind:u.VertexBuffer.MatricesWeightsExtraKind,accessorType:"VEC4",accessorComponentType:5126,byteStride:16}];if(l){let h=null;const f=this.getMeshPrimitiveMode(l),d={},m=l.morphTargetManager;for(const e of c){const n=e.kind,o=e.accessorComponentType;if(l.isVerticesDataPresent(n)){const a=this.getVertexBufferFromMesh(n,l);e.byteStride=a?a.getSize()*u.VertexBuffer.GetTypeByteLength(e.accessorComponentType):4*u.VertexBuffer.DeduceStride(n),12===e.byteStride&&(e.accessorType="VEC3"),this.createBufferViewKind(n,o,t,r,e.byteStride,s),e.bufferViewIndex=this._bufferViews.length-1,d[n]=e.bufferViewIndex}}if(l.getTotalIndices()){const e=l.getIndices();if(e){const t=4*e.length;a=p._CreateBufferView(0,r.getByteOffset(),t,void 0,"Indices - "+l.name),this._bufferViews.push(a),h=this._bufferViews.length-1;for(let t=0,s=e.length;t<s;++t)r.setUInt32(e[t])}}if(l.subMeshes)for(const a of l.subMeshes){let g=a.getMaterial()||l.getScene().defaultMaterial,_=null;if(g)if(l instanceof u.LinesMesh){const e={name:l.name+" material"};(!l.color.equals(u.Color3.White())||l.alpha<1)&&(e.pbrMetallicRoughness={baseColorFactor:l.color.asArray().concat([l.alpha])}),this._materials.push(e),_=this._materials.length-1}else if("MultiMaterial"===g.getClassName()){const e=g.subMaterials[a.materialIndex];e&&(g=e,_=this._materialMap[g.uniqueId])}else _=this._materialMap[g.uniqueId];const x=null!=_?this._materials[_]:null,T={attributes:{}};this.setPrimitiveMode(T,f);for(const e of c){const r=e.kind;if(!(r!==u.VertexBuffer.UVKind&&r!==u.VertexBuffer.UV2Kind||this._options.exportUnusedUVs||x&&this._glTFMaterialExporter._hasTexturesPresent(x)))continue;const n=l.getVerticesData(r);if(n){const o=this.getVertexBufferFromMesh(r,l);if(o){const a=o.getSize(),l=e.bufferViewIndex;if(null!=l){i={min:null,max:null},r==u.VertexBuffer.PositionKind&&(i=p._CalculateMinMaxPositions(n,0,n.length/a,s));const o=p._CreateAccessor(l,r+" - "+t.name,e.accessorType,e.accessorComponentType,n.length/a,0,i.min,i.max);this._accessors.push(o),this.setAttributeKind(T,r)}}}}if(h){const e=p._CreateAccessor(h,"indices - "+t.name,"SCALAR",5125,a.indexCount,4*a.indexStart,null,null);this._accessors.push(e),T.indices=this._accessors.length-1}if(null!=_&&Object.keys(T.attributes).length>0){const e=null!==l.overrideMaterialSideOrientation?l.overrideMaterialSideOrientation:g.sideOrientation;if(e==u.Material.ClockWiseSideOrientation&&this._babylonScene.useRightHandedSystem||e==u.Material.ClockWiseSideOrientation&&s&&l.overrideMaterialSideOrientation!==(null===(n=l.material)||void 0===n?void 0:n.sideOrientation)){let t=null!=h?this._bufferViews[h].byteOffset:null;null==t&&(t=0);let n=null;if(null!=h&&(n=l.getIndices()),n)this.reorderIndicesBasedOnPrimitiveMode(a,f,n,t,r);else for(const t of c){const n=l.getVerticesData(t.kind);if(n){let o=this._bufferViews[d[t.kind]].byteOffset;o||(o=0),this.reorderVertexAttributeDataBasedOnPrimitiveMode(a,f,e,t.kind,n,o,r,s)}}}T.material=_}if(m){let e;for(let t=0;t<m.numTargets;++t)e=m.getTarget(t),this.setMorphTargetAttributes(a,T,e,r,s)}e.primitives.push(T),this._extensionsPostExportMeshPrimitiveAsync("postExport",T,a,r),o.push()}}return Promise.all(o).then((()=>{}))}isBabylonCoordinateSystemConvertingNode(e){return e instanceof u.TransformNode&&("__root__"===e.name&&!(1===e.getWorldMatrix().determinant()||e instanceof u.Mesh&&null!==e.geometry||e instanceof u.InstancedMesh&&null!==e.sourceMesh.geometry||this._includeCoordinateSystemConversionNodes))}createSceneAsync(e,t){const r={nodes:[]};let s,n,o;const a=[...e.transformNodes,...e.meshes,...e.lights,...e.cameras],i=[];this._convertToRightHandedSystem=!e.useRightHandedSystem,this._convertToRightHandedSystemMap={},e.rootNodes.forEach((e=>{this._convertToRightHandedSystemMap[e.uniqueId]=this._convertToRightHandedSystem,e.getDescendants(!1).forEach((e=>{this._convertToRightHandedSystemMap[e.uniqueId]=this._convertToRightHandedSystem}))})),e.rootNodes.forEach((e=>{if(this.isBabylonCoordinateSystemConvertingNode(e)){i.push(e);const t=a.indexOf(e);-1!==t&&a.splice(t,1),e.getDescendants(!1).forEach((e=>{this._convertToRightHandedSystemMap[e.uniqueId]=!1}))}}));const l=new Map;e.cameras.forEach((e=>{const t={type:e.mode===u.Camera.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(e.name&&(t.name=e.name),"perspective"===t.type)t.perspective={aspectRatio:e.getEngine().getAspectRatio(e),yfov:e._cache.fovMode===u.Camera.FOVMODE_VERTICAL_FIXED?e.fov:e.fov*e._cache.aspectRatio,znear:e.minZ,zfar:e.maxZ};else if("orthographic"===t.type){const r=e.orthoLeft&&e.orthoRight?.5*(e.orthoRight-e.orthoLeft):.5*e.getEngine().getRenderWidth(),s=e.orthoBottom&&e.orthoTop?.5*(e.orthoTop-e.orthoBottom):.5*e.getEngine().getRenderHeight();t.orthographic={xmag:r,ymag:s,znear:e.minZ,zfar:e.maxZ}}l.set(e,this._cameras.length),this._cameras.push(t)}));const[c,h]=this.getExportNodes(a);return this._glTFMaterialExporter._convertMaterialsToGLTFAsync(h,"image/png",!0).then((()=>this.createNodeMapAndAnimationsAsync(e,c,t).then((c=>this.createSkinsAsync(e,c,t).then((e=>{if(this._nodeMap=c,this._totalByteLength=t.getByteOffset(),null==this._totalByteLength)throw new Error("undefined byte length!");for(const t of a)if(s=this._nodeMap[t.uniqueId],void 0!==s){if(n=this._nodes[s],t.metadata&&(this._options.metadataSelector?n.extras=this._options.metadataSelector(t.metadata):t.metadata.gltf&&(n.extras=t.metadata.gltf.extras)),t instanceof u.Camera&&(n.camera=l.get(t)),t.parent&&-1===i.indexOf(t.parent)||(this._options.shouldExportNode&&!this._options.shouldExportNode(t)?u.Tools.Log("Omitting "+t.name+" from scene."):(this._convertToRightHandedSystemMap[t.uniqueId]&&(n.translation&&(n.translation[2]*=-1,n.translation[0]*=-1),n.rotation=n.rotation?u.Quaternion.FromArray([0,1,0,0]).multiply(u.Quaternion.FromArray(n.rotation)).asArray():u.Quaternion.FromArray([0,1,0,0]).asArray()),r.nodes.push(s))),t instanceof u.Mesh){const r=t;r.skeleton&&(n.skin=e[r.skeleton.uniqueId])}if(o=t.getDescendants(!0),!n.children&&o&&o.length){const e=[];for(const t of o)null!=this._nodeMap[t.uniqueId]&&e.push(this._nodeMap[t.uniqueId]);e.length&&(n.children=e)}}r.nodes.length&&this._scenes.push(r)}))))))}getExportNodes(e){const t=[],r=new Set;for(const s of e)if(!this._options.shouldExportNode||this._options.shouldExportNode(s))if(t.push(s),"Mesh"===s.getClassName()){const e=s;e.material&&r.add(e.material)}else{const e=s.getChildMeshes(!1);for(const t of e)t.material&&r.add(t.material)}else s.name;return[t,r]}createNodeMapAndAnimationsAsync(e,t,r){let s=Promise.resolve();const n={};let o;const a={name:"runtime animations",channels:[],samplers:[]},i=[];for(const l of t)s=s.then((()=>{const t=this._convertToRightHandedSystemMap[l.uniqueId];return this.createNodeAsync(l,r,t,n).then((s=>{const c=this._extensionsPostExportNodeAsync("createNodeAsync",s,l,n);return null==c?(u.Tools.Warn(`Not exporting node ${l.name}`),Promise.resolve()):c.then((s=>{s&&(this._nodes.push(s),o=this._nodes.length-1,n[l.uniqueId]=o,e.animationGroups.length||(m._CreateMorphTargetAnimationFromMorphTargetAnimations(l,a,i,n,this._nodes,r,this._bufferViews,this._accessors,t,this._animationSampleRate),l.animations.length&&m._CreateNodeAnimationFromNodeAnimations(l,a,i,n,this._nodes,r,this._bufferViews,this._accessors,t,this._animationSampleRate)))}))}))}));return s.then((()=>(a.channels.length&&a.samplers.length&&this._animations.push(a),i.forEach((e=>{e.channels.length&&e.samplers.length&&this._animations.push(e)})),e.animationGroups.length&&m._CreateNodeAndMorphAnimationFromAnimationGroups(e,this._animations,n,this._nodes,r,this._bufferViews,this._accessors,this._convertToRightHandedSystemMap,this._animationSampleRate),n)))}createNodeAsync(e,t,r,s){return Promise.resolve().then((()=>{const s={},n={primitives:[]};if(e.name&&(s.name=e.name),e instanceof u.TransformNode){if(this.setNodeTransformation(s,e,r),e instanceof u.Mesh){const t=e.morphTargetManager;if(t&&t.numTargets>0){n.weights=[];for(let e=0;e<t.numTargets;++e)n.weights.push(t.getTarget(e).influence)}}return this.setPrimitiveAttributesAsync(n,e,t,r).then((()=>(n.primitives.length&&(this._meshes.push(n),s.mesh=this._meshes.length-1),s)))}return e instanceof u.Camera?(this.setCameraTransformation(s,e,r),s):s}))}createSkinsAsync(e,t,r){var s;const n=Promise.resolve(),o={};for(const n of e.skeletons){const e={joints:[]},a=[],i={};let l=-1;for(let e=0;e<n.bones.length;++e){const t=n.bones[e],r=null!==(s=t.getIndex())&&void 0!==s?s:e;-1!==r&&(i[r]=t,r>l&&(l=r))}for(let r=0;r<=l;++r){const s=i[r];a.push(s.getInvertedAbsoluteTransform());const n=s.getTransformNode();n?e.joints.push(t[n.uniqueId]):u.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const c=64,h=a.length*c,f=r.getByteOffset(),d=p._CreateBufferView(0,f,h,void 0,"InverseBindMatrices - "+n.name);this._bufferViews.push(d);const m=this._bufferViews.length-1,g=p._CreateAccessor(m,"InverseBindMatrices - "+n.name,"MAT4",5126,a.length,null,null,null),_=this._accessors.push(g)-1;e.inverseBindMatrices=_,this._skins.push(e),o[n.uniqueId]=this._skins.length-1,a.forEach((e=>{e.m.forEach((e=>{r.setFloat32(e)}))}))}return n.then((()=>o))}}x._ExtensionNames=new Array,x._ExtensionFactories={};class T{constructor(e){this._arrayBuffer=new ArrayBuffer(e),this._dataView=new DataView(this._arrayBuffer),this._byteOffset=0}resizeBuffer(e){const t=new ArrayBuffer(e),r=new Uint8Array(this._arrayBuffer),s=new Uint8Array(t);for(let e=0,t=s.byteLength;e<t;++e)s[e]=r[e];return this._arrayBuffer=t,this._dataView=new DataView(this._arrayBuffer),t}getArrayBuffer(){return this.resizeBuffer(this.getByteOffset())}getByteOffset(){if(null==this._byteOffset)throw new Error("Byte offset is undefined!");return this._byteOffset}setUInt8(e,t){null!=t?t<this._byteOffset?this._dataView.setUint8(t,e):u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+1>this._arrayBuffer.byteLength&&this.resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint8(this._byteOffset,e),this._byteOffset+=1)}setUInt16(e,t){null!=t?t<this._byteOffset?this._dataView.setUint16(t,e,!0):u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+2>this._arrayBuffer.byteLength&&this.resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint16(this._byteOffset,e,!0),this._byteOffset+=2)}getUInt32(e){if(e<this._byteOffset)return this._dataView.getUint32(e,!0);throw u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"),new Error("BinaryWriter: byteoffset is greater than the current binary buffer length!")}getVector3Float32FromRef(e,t){t+8>this._byteOffset?u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(e.x=this._dataView.getFloat32(t,!0),e.y=this._dataView.getFloat32(t+4,!0),e.z=this._dataView.getFloat32(t+8,!0))}setVector3Float32FromRef(e,t){t+8>this._byteOffset?u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._dataView.setFloat32(t,e.x,!0),this._dataView.setFloat32(t+4,e.y,!0),this._dataView.setFloat32(t+8,e.z,!0))}getVector4Float32FromRef(e,t){t+12>this._byteOffset?u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(e.x=this._dataView.getFloat32(t,!0),e.y=this._dataView.getFloat32(t+4,!0),e.z=this._dataView.getFloat32(t+8,!0),e.w=this._dataView.getFloat32(t+12,!0))}setVector4Float32FromRef(e,t){t+12>this._byteOffset?u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._dataView.setFloat32(t,e.x,!0),this._dataView.setFloat32(t+4,e.y,!0),this._dataView.setFloat32(t+8,e.z,!0),this._dataView.setFloat32(t+12,e.w,!0))}setFloat32(e,t){isNaN(e)&&u.Tools.Error("Invalid data being written!"),null!=t&&(t<this._byteOffset?this._dataView.setFloat32(t,e,!0):u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary length!")),this._byteOffset+4>this._arrayBuffer.byteLength&&this.resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setFloat32(this._byteOffset,e,!0),this._byteOffset+=4}setUInt32(e,t){null!=t?t<this._byteOffset?this._dataView.setUint32(t,e,!0):u.Tools.Error("BinaryWriter: byteoffset is greater than the current binary buffer length!"):(this._byteOffset+4>this._arrayBuffer.byteLength&&this.resizeBuffer(2*this._arrayBuffer.byteLength),this._dataView.setUint32(this._byteOffset,e,!0),this._byteOffset+=4)}}var y=0;class A{static GLTFAsync(e,t,r){return e.whenReadyAsync().then((()=>{const s=t.replace(/\.[^/.]+$/,"");return new x(e,r)._generateGLTFAsync(s)}))}static _PreExportAsync(e,t){return Promise.resolve().then((()=>t&&t.exportWithoutWaitingForScene?Promise.resolve():e.whenReadyAsync()))}static _PostExportAsync(e,t,r){return Promise.resolve().then((()=>(r&&r.exportWithoutWaitingForScene,t)))}static GLBAsync(e,t,r){return this._PreExportAsync(e,r).then((()=>{const s=t.replace(/\.[^/.]+$/,"");return new x(e,r)._generateGLBAsync(s).then((t=>this._PostExportAsync(e,t,r)))}))}}u.ShaderStore.ShadersStore.textureTransformPixelShader="precision highp float;varying vec2 vUV;uniform sampler2D textureSampler;uniform mat4 textureTransformMat;void main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\nvec2 uvTransformed=(textureTransformMat*vec4(vUV.xy,1,1)).xy;gl_FragColor=texture2D(textureSampler,uvTransformed);\n#define CUSTOM_FRAGMENT_MAIN_END\n}";const b="KHR_texture_transform";class F{constructor(e){this._recordedTextures=[],this.name=b,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){for(const e of this._recordedTextures)e.dispose()}get wasUsed(){return this._wasUsed}postExportTexture(e,t,r){if(r&&(0===r.uAng&&0===r.wAng&&0===r.vAng||0===r.uRotationCenter&&0===r.vRotationCenter)){const e={};let s=!1;if(0===r.uOffset&&0===r.vOffset||(e.offset=[r.uOffset,r.vOffset],s=!0),1===r.uScale&&1===r.vScale||(e.scale=[r.uScale,r.vScale],s=!0),0!==r.wAng&&(e.rotation=r.wAng,s=!0),0!==r.coordinatesIndex&&(e.texCoord=r.coordinatesIndex,s=!0),!s)return;this._wasUsed=!0,t.extensions||(t.extensions={}),t.extensions[b]=e}}preExportTextureAsync(e,t,r){return new Promise(((r,s)=>{const n=t.getScene();if(!n)return void s(`${e}: "scene" is not defined for Babylon texture ${t.name}!`);let o=!1;if(0===t.uAng&&0===t.wAng&&0===t.vAng||0===t.uRotationCenter&&0===t.vRotationCenter||(o=!0),o)return this._textureTransformTextureAsync(t,n).then((e=>{r(e)})).catch((e=>{s(e)}));r(t)}))}_textureTransformTextureAsync(e,t){return new Promise((r=>{const s=new u.ProceduralTexture(`${e.name}`,e.getSize(),"textureTransform",t);s||(u.Tools.Log(`Cannot create procedural texture for ${e.name}!`),r(e)),s.reservedDataStore={hidden:!0,source:e},this._recordedTextures.push(s),s.coordinatesIndex=e.coordinatesIndex,s.setTexture("textureSampler",e),s.setMatrix("textureTransformMat",e.getTextureMatrix()),s.isReady()?(s.render(),r(s)):s.getEffect().executeWhenCompiled((()=>{s.render(),r(s)}))}))}}x.RegisterExtension(b,(e=>new F(e)));const M="KHR_lights_punctual";class E{constructor(e){this.name=M,this.enabled=!0,this.required=!1,this._exporter=e}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions.KHR_lights_punctual=this._lights}postExportNodeAsync(e,t,r,s){return new Promise(((n,o)=>{if(t&&r instanceof u.ShadowLight){const o=r;let a;const i=o.getTypeID()==u.Light.LIGHTTYPEID_POINTLIGHT?"point":o.getTypeID()==u.Light.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":o.getTypeID()==u.Light.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(null==i)u.Logger.Warn(`${e}: Light ${o.name} is not supported in KHR_lights_punctual`);else{const l=o.position.clone(),c=this._exporter._convertToRightHandedSystemMap[r.uniqueId];if(l.equals(u.Vector3.Zero())||(c&&p._GetRightHandedPositionVector3FromRef(l),t.translation=l.asArray()),"point"!==i){const e=o.direction,r=-Math.atan2(e.z*(this._exporter._babylonScene.useRightHandedSystem?-1:1),e.x)+Math.PI/2,s=Math.sqrt(e.x*e.x+e.z*e.z),n=-Math.atan2(e.y,s),a=u.Quaternion.RotationYawPitchRoll(r,n,0);c&&p._GetRightHandedQuaternionFromRef(a),a.equals(u.Quaternion.Identity())||(t.rotation=a.asArray())}if(o.falloffType!==u.Light.FALLOFF_GLTF&&u.Logger.Warn(`${e}: Light falloff for ${o.name} does not match the KHR_lights_punctual specification!`),a={type:i},o.diffuse.equals(u.Color3.White())||(a.color=o.diffuse.asArray()),1!==o.intensity&&(a.intensity=o.intensity),o.range!==Number.MAX_VALUE&&(a.range=o.range),"spot"===i){const e=o;e.angle!==Math.PI/2&&(null==a.spot&&(a.spot={}),a.spot.outerConeAngle=e.angle/2),0!==e.innerAngle&&(null==a.spot&&(a.spot={}),a.spot.innerConeAngle=e.innerAngle/2)}null==this._lights&&(this._lights={lights:[]}),this._lights.lights.push(a);const h={light:this._lights.lights.length-1},f=r.parent;if(f&&1==f.getChildren().length){const e=this._exporter._nodes[s[f.uniqueId]];if(e){const r=u.TmpVectors.Matrix[0],s=u.TmpVectors.Matrix[1],a=e.translation?new u.Vector3(e.translation[0],e.translation[1],e.translation[2]):u.Vector3.Zero(),i=e.rotation?new u.Quaternion(e.rotation[0],e.rotation[1],e.rotation[2],e.rotation[3]):u.Quaternion.Identity(),l=e.scale?new u.Vector3(e.scale[0],e.scale[1],e.scale[2]):u.Vector3.One();u.Matrix.ComposeToRef(l,i,a,r),r.invertToRef(s);const c=u.TmpVectors.Matrix[2],f=t.translation?new u.Vector3(t.translation[0],t.translation[1],t.translation[2]):u.Vector3.Zero();o instanceof u.DirectionalLight&&f.subtractInPlace(this._exporter._babylonScene.useRightHandedSystem?o.direction:p._GetRightHandedPositionVector3(o.direction));const d=this._exporter._babylonScene.useRightHandedSystem?u.Quaternion.Identity():new u.Quaternion(0,1,0,0);t.rotation&&d.multiplyInPlace(new u.Quaternion(t.rotation[0],t.rotation[1],t.rotation[2],t.rotation[3]));const m=t.scale?new u.Vector3(t.scale[0],t.scale[1],t.scale[2]):u.Vector3.One();u.Matrix.ComposeToRef(m,d,f,c),c.multiplyToRef(s,c);const g=u.TmpVectors.Vector3[0],_=u.TmpVectors.Quaternion[0],x=u.TmpVectors.Vector3[1];return c.decompose(g,_,x),e.scale=g.asArray(),e.rotation=_.asArray(),e.translation=x.asArray(),null==e.extensions&&(e.extensions={}),e.extensions.KHR_lights_punctual=h,void n(null)}}null==t.extensions&&(t.extensions={}),t.extensions.KHR_lights_punctual=h}}n(t)}))}}x.RegisterExtension(M,(e=>new E(e)));const R="KHR_materials_clearcoat";class C{constructor(e){this.name=R,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,r){const s=[];return r instanceof u.PBRBaseMaterial&&r.clearCoat.isEnabled?(r.clearCoat.texture&&s.push(r.clearCoat.texture),!r.clearCoat.useRoughnessFromMainTexture&&r.clearCoat.textureRoughness&&s.push(r.clearCoat.textureRoughness),r.clearCoat.bumpTexture&&s.push(r.clearCoat.bumpTexture),s):[]}postExportMaterialAsync(e,t,r){return new Promise(((e,s)=>{if(r instanceof u.PBRBaseMaterial){if(!r.clearCoat.isEnabled)return void e(t);this._wasUsed=!0,t.extensions=t.extensions||{};const s=this._exporter._glTFMaterialExporter._getTextureInfo(r.clearCoat.texture);let n;n=r.clearCoat.useRoughnessFromMainTexture?this._exporter._glTFMaterialExporter._getTextureInfo(r.clearCoat.texture):this._exporter._glTFMaterialExporter._getTextureInfo(r.clearCoat.textureRoughness),r.clearCoat.isTintEnabled&&u.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${r.name}`),r.clearCoat.remapF0OnInterfaceChange&&u.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${r.name}`);const o=this._exporter._glTFMaterialExporter._getTextureInfo(r.clearCoat.bumpTexture),a={clearcoatFactor:r.clearCoat.intensity,clearcoatTexture:null!=s?s:void 0,clearcoatRoughnessFactor:r.clearCoat.roughness,clearcoatRoughnessTexture:null!=n?n:void 0,clearcoatNormalTexture:null!=o?o:void 0,hasTextures:()=>null!==a.clearcoatTexture||null!==a.clearcoatRoughnessTexture||null!==a.clearcoatRoughnessTexture};t.extensions.KHR_materials_clearcoat=a}e(t)}))}}x.RegisterExtension(R,(e=>new C(e)));const V="KHR_materials_sheen";class v{constructor(e){this.name=V,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=e}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(e,t,r){return r instanceof u.PBRMaterial&&r.sheen.isEnabled&&r.sheen.texture?[r.sheen.texture]:[]}postExportMaterialAsync(e,t,r){return new Promise(((e,s)=>{var n,o,a,i;if(r instanceof u.PBRMaterial){if(!r.sheen.isEnabled)return void e(t);this._wasUsed=!0,null==t.extensions&&(t.extensions={});const s={sheenColorFactor:r.sheen.color.asArray(),sheenRoughnessFactor:null!==(n=r.sheen.roughness)&&void 0!==n?n:0,hasTextures:()=>null!==s.sheenColorTexture||null!==s.sheenRoughnessTexture};r.sheen.texture&&(s.sheenColorTexture=null!==(o=this._exporter._glTFMaterialExporter._getTextureInfo(r.sheen.texture))&&void 0!==o?o:void 0),r.sheen.textureRoughness&&!r.sheen.useRoughnessFromMainTexture?s.sheenRoughnessTexture=null!==(a=this._exporter._glTFMaterialExporter._getTextureInfo(r.sheen.textureRoughness))&&void 0!==a?a:void 0:r.sheen.texture&&r.sheen.useRoughnessFromMainTexture&&(s.sheenRoughnessTexture=null!==(i=this._exporter._glTFMaterialExporter._getTextureInfo(r.sheen.texture))&&void 0!==i?i:void 0),t.extensions.KHR_materials_sheen=s}e(t)}))}}x.RegisterExtension(V,(e=>new v(e)));const w="KHR_materials_unlit";class S{constructor(e){this.name=w,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(e,t,r){return new Promise(((e,s)=>{let n=!1;r instanceof u.PBRMaterial?n=r.unlit:r instanceof u.StandardMaterial&&(n=r.disableLighting),n&&(this._wasUsed=!0,null==t.extensions&&(t.extensions={}),t.extensions.KHR_materials_unlit={}),e(t)}))}}x.RegisterExtension(w,(e=>new S(e)));class B{static CreateSTL(e,t=!0,r="stlmesh",s=!1,n=!0,o=!1){const a=function(e,t,r){const s=[3*e[r],3*e[r+1],3*e[r+2]],n=[new u.Vector3(t[s[0]],t[s[0]+2],t[s[0]+1]),new u.Vector3(t[s[1]],t[s[1]+2],t[s[1]+1]),new u.Vector3(t[s[2]],t[s[2]+2],t[s[2]+1])],o=n[0].subtract(n[1]),a=n[2].subtract(n[1]);return{v:n,n:u.Vector3.Cross(a,o).normalize()}},i=function(e,t,r,s){return t=l(e,t,r.x,s),t=l(e,t,r.y,s),l(e,t,r.z,s)},l=function(e,t,r,s){return e.setFloat32(t,r,s),t+4};let c,h=0,f=0;if(s){for(let t=0;t<e.length;t++){const r=e[t].getIndices();h+=r?r.length/3:0}const t=new ArrayBuffer(84+50*h);c=new DataView(t),f+=80,c.setUint32(f,h,n),f+=4}else c="solid stlmesh\r\n";for(let t=0;t<e.length;t++){const r=e[t];o||r.bakeCurrentTransformIntoVertices();const l=r.getVerticesData(u.VertexBuffer.PositionKind)||[],h=r.getIndices()||[];for(let e=0;e<h.length;e+=3){const t=a(h,l,e);s?(f=i(c,f,t.n,n),f=i(c,f,t.v[0],n),f=i(c,f,t.v[1],n),f=i(c,f,t.v[2],n),f+=2):(c+="facet normal "+t.n.x+" "+t.n.y+" "+t.n.z+"\r\n",c+="\touter loop\r\n",c+="\t\tvertex "+t.v[0].x+" "+t.v[0].y+" "+t.v[0].z+"\r\n",c+="\t\tvertex "+t.v[1].x+" "+t.v[1].y+" "+t.v[1].z+"\r\n",c+="\t\tvertex "+t.v[2].x+" "+t.v[2].y+" "+t.v[2].z+"\r\n",c+="\tendloop\r\n",c+="endfacet\r\n")}}if(s||(c+="endsolid stlmesh"),t){const e=document.createElement("a"),t=new Blob([c],{type:"application/octet-stream"});e.href=window.URL.createObjectURL(t),e.download=r+".stl",e.click()}return c}}const I=void 0!==s.g?s.g:"undefined"!=typeof window?window:void 0;if(void 0!==I){I.BABYLON=I.BABYLON||{};const e=I.BABYLON;e.GLTF2=e.GLTF2||{},e.GLTF2.Exporter=e.GLTF2.Exporter||{},e.GLTF2.Exporter.Extensions=e.GLTF2.Exporter.Extensions||{};const s=[];for(var N in t)e[N]=t[N],s.push(N);for(var N in r)e[N]=r[N],s.push(N);for(var N in o)e[N]=o[N],s.push(N);for(var N in a)e.GLTF2.Exporter.Extensions[N]=a[N],s.push(N);for(var N in i)s.indexOf(N)>-1||(e.GLTF2.Exporter[N]=i[N])}const P=void 0!==s.g?s.g:"undefined"!=typeof window?window:void 0;if(void 0!==P)for(const t in e)P.BABYLON[t]=e[t];const L=void 0!==s.g?s.g:"undefined"!=typeof window?window:void 0;if(void 0!==L)for(const e in l)L.BABYLON[e]=l[e];const O=c})(),n.default})()}));
//# sourceMappingURL=babylonjs.serializers.min.js.map